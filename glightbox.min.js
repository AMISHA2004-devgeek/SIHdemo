!function (e, t) {
    "object" == typeof exports && "undefined" != typeof module
        ? module.exports = t()
        : "function" == typeof define && define.amd
        ? define(t)
        : (e = e || self).GLightbox = t()
}
(function () {
    "use strict";

    function getType(value) {
        return (typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (v) { return typeof v; }
            : function (v) { return v && typeof Symbol === "function" && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v; }
        )(value);
    }

    function isInstanceOf(value, Constructor) {
        if (!(value instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }

    function defineProperties(target, properties) {
        properties.forEach(function (prop) {
            prop.enumerable = prop.enumerable || false;
            prop.configurable = true;
            if ("value" in prop) prop.writable = true;
            Object.defineProperty(target, prop.key, prop);
        });
    }

    function createClass(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    }

    const now = Date.now();

    function mergeObjects() {
        let result = {};
        let deep = true;
        let startIndex = 0;

        if (Object.prototype.toString.call(arguments[0]) === "[object Boolean]") {
            deep = arguments[0];
            startIndex++;
        }

        for (let i = startIndex; i < arguments.length; i++) {
            const obj = arguments[i];
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    if (deep && Object.prototype.toString.call(obj[key]) === "[object Object]") {
                        result[key] = mergeObjects(true, result[key], obj[key]);
                    } else {
                        result[key] = obj[key];
                    }
                }
            }
        }

        return result;
    }

    function iterateCollection(collection, callback) {
        if ((isNode(collection) || collection === window || collection === document) && (collection = [collection]), isArray(collection) || isArguments(collection) || (collection = [collection]), collection.length > 0) {
            if (isArray(collection) && !isArguments(collection)) {
                for (let i = 0; i < collection.length; i++) {
                    if (callback.call(collection[i], collection[i], i, collection) === false) break;
                }
            } else if (isArguments(collection)) {
                for (const key in collection) {
                    if (Object.prototype.hasOwnProperty.call(collection, key) && callback.call(collection[key], collection[key], key, collection) === false) break;
                }
            }
        }
    }

    function findEvent(e, eventName, fn) {
        const events = e[Symbol.for('events')] = e[Symbol.for('events')] || [];
        const result = { all: events, evt: null, found: null };
        
        if (eventName && fn) {
            iterateCollection(events, function (event, index) {
                if (event.eventName === eventName && event.fn.toString() === fn.toString()) {
                    result.found = true;
                    result.evt = index;
                    return false;
                }
            });
        }

        return result;
    }

    function addEventListener(eventType, options = {}, context = null) {
        const { onElement, withCallback, avoidDuplicate = true, once = false, useCapture = false } = options;
        const elements = onElement || [];
        const callback = function (event) {
            if (typeof withCallback === 'function') {
                withCallback.call(context, event, this);
            }
            if (once) {
                callback.destroy();
            }
        };
        
        if (Array.isArray(elements)) {
            elements.forEach(element => {
                const eventList = findEvent(element, eventType, callback);
                if (element.addEventListener && (avoidDuplicate && !eventList.found || !avoidDuplicate)) {
                    element.addEventListener(eventType, callback, useCapture);
                    eventList.all.push({ eventName: eventType, fn: callback });
                }
            });
        } else {
            const nodeList = document.querySelectorAll(elements);
            nodeList.forEach(element => {
                const eventList = findEvent(element, eventType, callback);
                if (element.addEventListener && (avoidDuplicate && !eventList.found || !avoidDuplicate)) {
                    element.addEventListener(eventType, callback, useCapture);
                    eventList.all.push({ eventName: eventType, fn: callback });
                }
            });
        }

        callback.destroy = function () {
            elements.forEach(element => {
                const eventList = findEvent(element, eventType, callback);
                if (eventList.found) {
                    eventList.all.splice(eventList.evt, 1);
                }
                if (element.removeEventListener) {
                    element.removeEventListener(eventType, callback, useCapture);
                }
            });
        };

        return callback;
    }

    function addClass(element, classNames) {
        classNames.split(' ').forEach(className => element.classList.add(className));
    }

    function removeClass(element, classNames) {
        classNames.split(' ').forEach(className => element.classList.remove(className));
    }

    function hasClass(element, className) {
        return element.classList.contains(className);
    }

    function closestMatchingAncestor(element, selector) {
        while (element !== document.body) {
            if (element = element.parentElement) {
                if (element.matches(selector) || element.msMatchesSelector(selector)) {
                    return element;
                }
            } else {
                return false;
            }
        }
    }
})();

    function g(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (!e || "" === t) return !1;
        if ("none" === t) return T(i) && i(), !1;
        var n = x(),
            s = t.split(" ");
        o(s, function (t) { h(e, "g" + t) });
        a(n, { onElement: e, avoidDuplicate: !1, once: !0, withCallback: function (e, t) {
            o(s, function (e) { d(t, "g" + e) });
            T(i) && i();
        }});
    }

    function v(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        if ("" === t) return e.style.webkitTransform = "", e.style.MozTransform = "", e.style.msTransform = "", e.style.OTransform = "", e.style.transform = "", !1;
        e.style.webkitTransform = t;
        e.style.MozTransform = t;
        e.style.msTransform = t;
        e.style.OTransform = t;
        e.style.transform = t;
    }

    function f(e) {
        e.style.display = "block";
    }

    function p(e) {
        e.style.display = "none";
    }

    function m(e) {
        var t = document.createDocumentFragment(),
            i = document.createElement("div");
        for (i.innerHTML = e; i.firstChild;) t.appendChild(i.firstChild);
        return t;
    }

    function y() {
        return {
            width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
            height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        };
    }

    function x() {
        var e, t = document.createElement("fakeelement"),
            i = {
                animation: "animationend",
                OAnimation: "oAnimationEnd",
                MozAnimation: "animationend",
                WebkitAnimation: "webkitAnimationEnd"
            };
        for (e in i) if (void 0 !== t.style[e]) return i[e];
    }

    function b(e, t, i, n) {
        if (e()) t();
        else {
            var s;
            i || (i = 100);
            var l = setInterval(function () {
                e() && (clearInterval(l), s && clearTimeout(s), t());
            }, i);
            n && (s = setTimeout(function () { clearInterval(l) }, n));
        }
    }
    function S(e, t, i) {
        if (I(e)) {
            console.error("Inject assets error");
        } else if (T(t) && (i = t, t = false)) {
            if (C(t) && t in window) {
                if (T(i)) i();
            }
        } else {
            var n;
            if (e.indexOf(".css") !== -1) {
                if ((n = document.querySelectorAll(e)).length > 0) {
                    n.forEach(function (el) {
                        // Apply CSS loading logic here
                    });
                }
            }
        }
    }
    
    function X(e) {
        if (e.events.hasOwnProperty("keyboard")) return false;
        
        e.events.keyboard = a("keydown", {
            onElement: window,
            withCallback: function (t, i) {
                var n = (t = t || window.event).keyCode;
                if (n === 9) {
                    var s = document.querySelector(".gbtn.focused");
                    if (!s) {
                        var l = document.activeElement && document.activeElement.nodeName.toLowerCase();
                        if (["input", "textarea", "button"].indexOf(l) >= 0) return;
                    }
                    t.preventDefault();
                    var o = document.querySelectorAll(".gbtn[data-taborder]");
                    if (!o || o.length <= 0) return;
                    if (!s) {
                        var r = z();
                        if (r) {
                            r.focus();
                            h(r, "focused");
                        }
                    } else {
                        var a = z(s.getAttribute("data-taborder"));
                        d(s, "focused");
                        if (a) {
                            a.focus();
                            h(a, "focused");
                        }
                    }
                }
                if (n === 39) e.nextSlide();
                if (n === 37) e.prevSlide();
                if (n === 27) e.close();
            }
        });
    }
    
    function Y(e) {
        return Math.sqrt(e.x * e.x + e.y * e.y);
    }
    
    function q(e, t) {
        var i = (function (e, t) {
            var i = Y(e) * Y(t);
            if (i === 0) return 0;
            var n = function (e, t) {
                return e.x * t.x + e.y * t.y;
            }(e, t) / i;
            if (n > 1) n = 1;
            var angle = Math.acos(n);
            if (function (e, t) {
                return e.x * t.y - t.x * e.y;
            }(e, t) > 0) angle *= -1;
            return 180 * angle / Math.PI;
        })(e, t);
        return i;
    }
    
    class N {
        constructor(el) {
            this.handlers = [];
            this.el = el;
        }
    
        add(handler) {
            this.handlers.push(handler);
        }
    
        del(handler) {
            if (!handler) {
                this.handlers = [];
                return;
            }
            for (var i = this.handlers.length - 1; i >= 0; i--) {
                if (this.handlers[i] === handler) {
                    this.handlers.splice(i, 1);
                }
            }
        }
    
        dispatch() {
            this.handlers.forEach(handler => {
                if (typeof handler === 'function') {
                    handler.apply(this.el, arguments);
                }
            });
        }
    }
    
    function D(e, t) {
        var i = new N(e);
        i.add(t);
        return i;
    }
    
    if (!this.toleranceReached) {
                                this.setTranslate(this.dragContainer, 0, 0, true);
                              }
    setTimeout(() => {
                                this.instance.preventOutsideClick = false;
                                this.toleranceReached = false;
                                this.lastDirection = null;
                                this.dragging = false;
                                this.el.isDragging = false;
                                this.el.classList.remove("dragging");
                                this.slide.classList.remove("dragging-nav");
                                this.dragContainer.style.transform = "";
                                this.dragContainer.style.transition = "";
                              }, 100);
                            // GestureHandler class for handling touch gestures
class GestureHandler {
    constructor(element, callbacks = {}) {
        this.element = typeof element === 'string' ? document.querySelector(element) : element;
        this.start = this.start.bind(this);
        this.move = this.move.bind(this);
        this.end = this.end.bind(this);
        this.cancel = this.cancel.bind(this);

        // Event listeners
        this.element.addEventListener("touchstart", this.start, false);
        this.element.addEventListener("touchmove", this.move, false);
        this.element.addEventListener("touchend", this.end, false);
        this.element.addEventListener("touchcancel", this.cancel, false);

        // Initialize properties
        this.preV = { x: null, y: null };
        this.pinchStartLen = null;
        this.zoom = 1;
        this.isDoubleTap = false;
        this.rotate = this.createCallback(callbacks.rotate);
        this.touchStart = this.createCallback(callbacks.touchStart);
        this.multipointStart = this.createCallback(callbacks.multipointStart);
        this.multipointEnd = this.createCallback(callbacks.multipointEnd);
        this.pinch = this.createCallback(callbacks.pinch);
        this.swipe = this.createCallback(callbacks.swipe);
        this.tap = this.createCallback(callbacks.tap);
        this.doubleTap = this.createCallback(callbacks.doubleTap);
        this.longTap = this.createCallback(callbacks.longTap);
        this.singleTap = this.createCallback(callbacks.singleTap);
        this.pressMove = this.createCallback(callbacks.pressMove);
        this.twoFingerPressMove = this.createCallback(callbacks.twoFingerPressMove);
        this.touchMove = this.createCallback(callbacks.touchMove);
        this.touchEnd = this.createCallback(callbacks.touchEnd);
        this.touchCancel = this.createCallback(callbacks.touchCancel);

        // Additional properties
        this.translateContainer = this.element;
        this._cancelAllHandler = this.cancelAll.bind(this);
        window.addEventListener("scroll", this._cancelAllHandler);

        // Timing and position variables
        this.delta = null;
        this.last = null;
        this.now = null;
        this.tapTimeout = null;
        this.singleTapTimeout = null;
        this.longTapTimeout = null;
        this.swipeTimeout = null;
        this.x1 = this.x2 = this.y1 = this.y2 = null;
        this.preTapPosition = { x: null, y: null };
    }

    createCallback(callback) {
        return typeof callback === 'function' ? callback : () => {};
    }

    start(e) {
        if (e.touches) {
            if (e.target && e.target.nodeName && ["a", "button", "input"].indexOf(e.target.nodeName.toLowerCase()) >= 0) {
                console.log("ignore drag for this touched element", e.target.nodeName.toLowerCase());
            } else {
                this.now = Date.now();
                this.x1 = e.touches[0].pageX;
                this.y1 = e.touches[0].pageY;
                this.delta = this.now - (this.last || this.now);
                this.touchStart(e);

                if (this.preTapPosition.x !== null) {
                    this.isDoubleTap = this.delta > 0 && this.delta <= 250 &&
                        Math.abs(this.preTapPosition.x - this.x1) < 30 &&
                        Math.abs(this.preTapPosition.y - this.y1) < 30;
                    if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);
                }
                this.preTapPosition.x = this.x1;
                this.preTapPosition.y = this.y1;
                this.last = this.now;

                if (e.touches.length > 1) {
                    this._cancelLongTap();
                    this._cancelSingleTap();
                    const i = { x: e.touches[1].pageX - this.x1, y: e.touches[1].pageY - this.y1 };
                    this.preV.x = i.x;
                    this.preV.y = i.y;
                    this.pinchStartLen = this.getDistance(this.preV);
                    this.multipointStart(e);
                }
                this._preventTap = false;
                this.longTapTimeout = setTimeout(() => {
                    this.longTap(e);
                    this._preventTap = true;
                }, 750);
            }
        }
    }

    move(e) {
        if (e.touches) {
            const t = this.preV;
            const i = e.touches.length;
            const n = e.touches[0].pageX;
            const s = e.touches[0].pageY;

            if (this.isDoubleTap = false, i > 1) {
                const l = e.touches[1].pageX;
                const o = e.touches[1].pageY;
                const r = { x: e.touches[1].pageX - n, y: e.touches[1].pageY - s };

                if (t.x !== null && this.pinchStartLen > 0) {
                    e.zoom = this.getDistance(r) / this.pinchStartLen;
                    this.pinch(e);
                    e.angle = this.getAngle(r, t);
                    this.rotate(e);
                }
                t.x = r.x;
                t.y = r.y;

                if (this.x2 !== null && this.sx2 !== null) {
                    e.deltaX = (n - this.x2 + l - this.sx2) / 2;
                    e.deltaY = (s - this.y2 + o - this.sy2) / 2;
                } else {
                    e.deltaX = 0;
                    e.deltaY = 0;
                }
                this.x2 = n;
                this.y2 = s;
                this.sx2 = l;
                this.sy2 = o;
            }
            this.touchMove(e);
        }
    }

    end(e) {
        this._cancelLongTap();
        this._cancelSingleTap();
        if (this._preventTap) return;
        if (this.isDoubleTap) {
            this.doubleTap(e);
        } else {
            this.tap(e);
        }
        this.touchEnd(e);
    }

    cancel(e) {
        this._cancelLongTap();
        this._cancelSingleTap();
        this.touchCancel(e);
    }

    _cancelLongTap() {
        clearTimeout(this.longTapTimeout);
    }

    _cancelSingleTap() {
        clearTimeout(this.singleTapTimeout);
    }

    cancelAll() {
        this._cancelLongTap();
        this._cancelSingleTap();
        this._cancelAllHandler();
    }

    getDistance(point) {
        return Math.sqrt(point.x * point.x + point.y * point.y);
    }

    getAngle(point1, point2) {
        return Math.atan2(point1.y - point2.y, point1.x - point2.x) * (180 / Math.PI);
    }
}

// ImageSlider class for handling dragging of images
class ImageSlider {
    constructor(options = {}) {
        this.img = options.img || null;
        this.slide = options.slide || null;
        this.onclose = options.onclose || null;
        this.zoomedIn = false;
        this.active = false;
        this.currentX = null;
        this.currentY = null;
        this.initialX = null;
        this.initialY = null;
        this.xOffset = 0;
        this.yOffset = 0;

        // Event listeners
        this.img.addEventListener("mousedown", (e) => this.dragStart(e), false);
        this.img.addEventListener("mouseup", (e) => this.dragEnd(e), false);
        this.img.addEventListener("mousemove", (e) => this.drag(e), false);
        this.img.addEventListener("touchstart", (e) => this.dragStart(e), false);
        this.img.addEventListener("touchend", (e) => this.dragEnd(e), false);
        this.img.addEventListener("touchmove", (e) => this.drag(e), false);
    }}
    class ImageSlider {
        constructor(options = {}) {
            this.img = options.img || null; // Image element to be dragged
            this.slide = options.slide || null; // Slide element (optional)
            this.onclose = options.onclose || null; // Callback when dragging ends
            this.zoomedIn = false; // Track if the image is zoomed in
            this.active = false; // Track if dragging is active
            this.currentX = null; // Current X position
            this.currentY = null; // Current Y position
            this.initialX = null; // Initial X position
            this.initialY = null; // Initial Y position
            this.xOffset = 0; // X offset for dragging
            this.yOffset = 0; // Y offset for dragging
    
            // Event listeners
            this.img.addEventListener("mousedown", (e) => this.dragStart(e), false);
            this.img.addEventListener("mouseup", (e) => this.dragEnd(e), false);
            this.img.addEventListener("mousemove", (e) => this.drag(e), false);
            this.img.addEventListener("touchstart", (e) => this.dragStart(e), false);
            this.img.addEventListener("touchend", (e) => this.dragEnd(e), false);
            this.img.addEventListener("touchmove", (e) => this.drag(e), false);
        }
    
        dragStart(e) {
            e.preventDefault();
            if (this.zoomedIn) {
                if (e.type === "touchstart") {
                    this.initialX = e.touches[0].clientX - this.xOffset;
                    this.initialY = e.touches[0].clientY - this.yOffset;
                } else {
                    this.initialX = e.clientX - this.xOffset;
                    this.initialY = e.clientY - this.yOffset;
                }
                if (e.target === this.img) {
                    this.active = true;
                    this.img.classList.add("dragging");
                }
            } else {
                this.active = false;
            }
        }
    
        dragEnd(e) {
            e.preventDefault();
            this.initialX = this.currentX;
            this.initialY = this.currentY;
            this.active = false;
            setTimeout(() => {
                this.dragging = false;
                this.img.isDragging = false;
                this.img.classList.remove("dragging");
                if (typeof this.onclose === "function") {
                    this.onclose();
                }
            }, 100);
        }
    
        drag(e) {
            if (this.active) {
                e.preventDefault();
                if (e.type === "touchmove") {
                    this.currentX = e.touches[0].clientX - this.initialX;
                    this.currentY = e.touches[0].clientY - this.initialY;
                } else {
                    this.currentX = e.clientX - this.initialX;
                    this.currentY = e.clientY - this.initialY;
                }
                this.setTranslate(this.img, this.currentX, this.currentY);
            }
        }
    
        setTranslate(element, x, y) {
            element.style.transform = `translate3d(${x}px, ${y}px, 0)`;
        }
    }
    class ImageSlider {
        constructor(options = {}) {
            this.img = options.img || null;
            this.slide = options.slide || null;
            this.onclose = options.onclose || null;
            this.zoomedIn = false;
            this.active = false;
            this.currentX = null;
            this.currentY = null;
            this.initialX = null;
            this.initialY = null;
            this.xOffset = 0;
            this.yOffset = 0;
            this.lastDirection = null;
            this.dragging = false;
            this.doSlideChange = false;
            this.doSlideClose = false;
            this.toleranceX = options.toleranceX || 50; // Adjust as needed
            this.toleranceY = options.toleranceY || 50; // Adjust as needed
            
            // Event listeners
            this.img.addEventListener("mousedown", (e) => this.dragStart(e), false);
            this.img.addEventListener("mouseup", (e) => this.dragEnd(e), false);
            this.img.addEventListener("mousemove", (e) => this.drag(e), false);
            this.img.addEventListener("touchstart", (e) => this.dragStart(e), false);
            this.img.addEventListener("touchend", (e) => this.dragEnd(e), false);
            this.img.addEventListener("touchmove", (e) => this.drag(e), false);
        }
    
        dragStart(e) {
            e.preventDefault();
            if (this.zoomedIn) {
                if (e.type === "touchstart") {
                    this.initialX = e.touches[0].clientX - this.xOffset;
                    this.initialY = e.touches[0].clientY - this.yOffset;
                } else {
                    this.initialX = e.clientX - this.xOffset;
                    this.initialY = e.clientY - this.yOffset;
                }
                if (e.target === this.img) {
                    this.active = true;
                    this.img.classList.add("dragging");
                }
            } else {
                this.active = false;
            }
        }
    
        dragEnd(e) {
            e.preventDefault();
            this.initialX = this.currentX;
            this.initialY = this.currentY;
            this.active = false;
            setTimeout(() => {
                this.dragging = false;
                this.img.isDragging = false;
                this.img.classList.remove("dragging");
                if (typeof this.onclose === "function") {
                    this.onclose();
                }
            }, 100);
        }
    
        drag(e) {
            if (this.active) {
                e.preventDefault();
                this.slide.classList.add("dragging-nav");
    
                if (e.type === "touchmove") {
                    this.currentX = e.touches[0].clientX - this.initialX;
                    this.currentY = e.touches[0].clientY - this.initialY;
                } else {
                    this.currentX = e.clientX - this.initialX;
                    this.currentY = e.clientY - this.initialY;
                }
    
                this.xOffset = this.currentX;
                this.yOffset = this.currentY;
                this.img.isDragging = true;
                this.dragging = true;
                this.doSlideChange = false;
                this.doSlideClose = false;
    
                const absX = Math.abs(this.currentX);
                const absY = Math.abs(this.currentY);
    
                if (absX > 0 && absX >= absY && (!this.lastDirection || this.lastDirection === "x")) {
                    this.yOffset = 0;
                    this.lastDirection = "x";
                    this.setTranslate(this.slide, this.currentX, 0);
                    const shouldChange = this.shouldChange();
                    if (!this.instance.settings.dragAutoSnap && shouldChange) {
                        this.doSlideChange = shouldChange;
                    }
                    if (this.instance.settings.dragAutoSnap && shouldChange) {
                        this.instance.preventOutsideClick = true;
                        this.toleranceReached = true;
                        this.active = false;
                        this.instance.preventOutsideClick = true;
                        this.dragEnd(null);
                        if (this.doSlideChange === "right") this.instance.prevSlide();
                        if (this.doSlideChange === "left") this.instance.nextSlide();
                    }
                }
    
                if (this.toleranceY > 0 && absY > 0 && absY >= absX && (!this.lastDirection || this.lastDirection === "y")) {
                    this.xOffset = 0;
                    this.lastDirection = "y";
                    this.setTranslate(this.slide, 0, this.currentY);
                    const shouldClose = this.shouldClose();
                    if (!this.instance.settings.dragAutoSnap && shouldClose) {
                        this.doSlideClose = true;
                    }
                    if (this.instance.settings.dragAutoSnap && shouldClose) {
                        this.instance.close();
                    }
                }
            }
        }
    
        setTranslate(element, x, y, noTransition = false) {
            element.style.transform = `translate3d(${x}px, ${y}px, 0)`;
            if (noTransition) {
                element.style.transition = "none";
            }
        }
    
        shouldChange() {
            let direction = false;
            if (Math.abs(this.currentX) >= this.toleranceX) {
                const swipeDirection = this.currentX > 0 ? "right" : "left";
                if (
                    (swipeDirection === "left" && this.slide !== this.slide.parentNode.lastChild) ||
                    (swipeDirection === "right" && this.slide !== this.slide.parentNode.firstChild)
                ) {
                    direction = swipeDirection;
                }
            }
            return direction;
        }
    
        shouldClose() {
            return Math.abs(this.currentY) >= this.toleranceY;
        }
    }
    
   
               
            class SwipeHandler {
                constructor() {
                    this.currentX = 0;
                    this.currentY = 0;
                    this.toleranceX = 30; // Adjust as needed
                    this.toleranceY = 30; // Adjust as needed
                    this.slide = null; // The current slide element
                }
            
                // Determine if the swipe should change the slide
                shouldChange() {
                    let direction = false;
                    if (Math.abs(this.currentX) >= this.toleranceX) {
                        const swipeDirection = this.currentX > 0 ? "right" : "left";
                        if (
                            (swipeDirection === "left" && this.slide !== this.slide.parentNode.lastChild) ||
                            (swipeDirection === "right" && this.slide !== this.slide.parentNode.firstChild)
                        ) {
                            direction = swipeDirection;
                        }
                    }
                    return direction;
                }
            
                // Determine if the swipe should close the lightbox
                shouldClose() {
                    return Math.abs(this.currentY) >= this.toleranceY;
                }
            
                // Set the translation for an element
                setTranslate(element, x, y, withTransition = false) {
                    element.style.transition = withTransition ? "all .2s ease" : "";
                    element.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                }
            }
            
            // Example functions related to slides and media
            function loadSlideMedia(element, link, index, callback) {
                const mediaContainer = element.querySelector(".gslide-media");
                const img = new Image();
                const titleId = `gSlideTitle_${index}`;
                const descId = `gSlideDesc_${index}`;
            
                img.addEventListener("load", () => {
                    if (typeof callback === "function") callback();
                }, false);
            
                img.src = link.href;
                if (link.sizes) img.sizes = link.sizes;
                if (link.srcset) img.srcset = link.srcset;
                if (link.alt) img.alt = link.alt;
                if (link.title) img.setAttribute("aria-labelledby", titleId);
                if (link.description) img.setAttribute("aria-describedby", descId);
                if (link._hasCustomWidth) img.style.width = link.width;
                if (link._hasCustomHeight) img.style.height = link.height;
            
                mediaContainer.insertBefore(img, mediaContainer.firstChild);
            }
            
            function setupVideoSlide(element, link, index) {
                const innerContainer = element.querySelector(".ginner-container");
                const videoId = `gvideo${index}`;
                const mediaContainer = element.querySelector(".gslide-media");
                const allPlayers = getAllPlayers(); // Assuming getAllPlayers is defined elsewhere
            
                innerContainer.classList.add("gvideo-container");
                mediaContainer.insertBefore(document.createElement('div').classList.add("gvideo-wrapper"), mediaContainer.firstChild);
            
                const videoWrapper = element.querySelector(".gvideo-wrapper");
                const videoSource = link.href;
                const videoProvider = link.videoProvider || "local";
                let videoElement = null;
            
                if (videoProvider === "local") {
                    videoElement = document.createElement('video');
                    videoElement.id = videoId;
                    videoElement.style.background = "#000";
                    videoElement.style.maxWidth = link.width;
                    videoElement.preload = "metadata";
                    videoElement.controls = true;
                    videoElement.classList.add("gvideo-local");
                    videoElement.innerHTML = `<source src="${videoSource}">`;
                }
            
                videoWrapper.appendChild(videoElement);
            }
            function setupVideoSlide(element, link, index) {
                const innerContainer = element.querySelector(".ginner-container");
                const videoId = `gvideo${index}`;
                const mediaContainer = element.querySelector(".gslide-media");
                const allPlayers = getAllPlayers(); // Assuming getAllPlayers is defined elsewhere
            
                innerContainer.classList.add("gvideo-container");
                const videoWrapper = document.createElement('div');
                videoWrapper.classList.add("gvideo-wrapper");
                mediaContainer.insertBefore(videoWrapper, mediaContainer.firstChild);
            
                const videoSource = link.href;
                const videoProvider = link.videoProvider || "local";
                const videoElement = videoProvider === "local"
                    ? `<video id="${videoId}" style="background:#000; max-width: ${link.width};" preload="metadata" x-webkit-airplay="allow" playsinline controls class="gvideo-local">
                         <source src="${videoSource}">
                       </video>`
                    : `<div id="${videoId}" data-plyr-provider="${videoProvider}" data-plyr-embed-id="${videoSource}"></div>`;
            
                videoWrapper.innerHTML = videoElement;
            
                const plyrConfig = getConfigForPlyr(); // Assuming getConfigForPlyr() is defined elsewhere
                const plyrInstance = new Plyr(`#${videoId}`, plyrConfig);
            
                plyrInstance.on('ready', (event) => {
                    allPlayers[videoId] = event.detail.plyr;
                    if (typeof link.onReady === 'function') link.onReady();
                });
            
                plyrInstance.on('enterfullscreen', handleFullscreen);
                plyrInstance.on('exitfullscreen', handleFullscreen);
            
                function handleFullscreen(event) {
                    const mediaElement = event.target.closest('.gslide-media');
                    if (event.type === 'enterfullscreen') {
                        mediaElement.classList.add('fullscreen');
                    } else if (event.type === 'exitfullscreen') {
                        mediaElement.classList.remove('fullscreen');
                    }
                }
            }
            
            function appendInlineContent(element, link, index) {
                const mediaContainer = element.querySelector(".gslide-media");
                const contentId = link.href ? link.href.split("#").pop().trim() : null;
                const inlineContent = link.content;
            
                let contentElement = null;
            
                if (inlineContent) {
                    if (isHTMLElement(inlineContent)) {
                        if (inlineContent.style.display === 'none') {
                            inlineContent.style.display = 'block';
                        }
                        contentElement = document.createElement('div');
                        contentElement.className = 'ginlined-content';
                        contentElement.appendChild(inlineContent);
                    } else if (isString(inlineContent)) {
                        contentElement = document.createElement('div');
                        contentElement.className = 'ginlined-content';
                        contentElement.innerHTML = inlineContent;
                    }
                }
            
                if (contentId) {
                    const existingContent = document.getElementById(contentId);
                    if (existingContent) {
                        const clonedContent = existingContent.cloneNode(true);
                        clonedContent.style.height = link.height;
                        clonedContent.style.maxWidth = link.width;
                        clonedContent.classList.add('ginlined-content');
                        contentElement = clonedContent;
                    }
                }
            
                if (contentElement) {
                    mediaContainer.appendChild(contentElement);
                } else {
                    console.error('Unable to append inline slide content', link);
                }
            }
            
            // Helper functions
            function isHTMLElement(element) {
                return element instanceof HTMLElement;
            }
            
            function isString(value) {
                return typeof value === 'string';
            }
            
            function getAllPlayers() {
                // Assuming a function to get all Plyr instances
                return {};
            }
            
            function getConfigForPlyr() {
                // Assuming a function to get Plyr configuration
                return {};
            }
            class InlineContentHandler {
                constructor() {
                    this.events = {};
                }
            
                showInlineContent(o, t, s, l, r, n) {
                    o.style.height = t.height;
                    o.style.width = t.width;
                    o.appendChild(s);
            
                    // Add close event listener
                    this.events["inlineclose" + r] = a("click", {
                        onElement: o.querySelectorAll(".gtrigger-close"),
                        withCallback: function(e) {
                            e.preventDefault();
                            l.close();  // Assuming `l` is an instance with a `close` method
                        }
                    });
            
                    // Call the callback function if it exists
                    T(n) && n();
                }
            }
            
                            // Function to embed a Vimeo video into a slide
function Z(e, t, i, n) {
    const mediaContainer = e.querySelector(".gslide-media");
    
    const createIframe = ({ url, allow, callback, appendTo }) => {
        const iframe = document.createElement("iframe");
        iframe.className = "vimeo-video gvideo";
        iframe.src = url;
        iframe.style.width = "100%";
        iframe.style.height = "100%";

        if (allow) {
            iframe.setAttribute("allow", allow);
        }

        iframe.onload = () => {
            iframe.onload = null; // Remove onload event listener after it fires
            mediaContainer.classList.add("node-ready");
            if (typeof callback === 'function') callback();
        };

        if (appendTo) {
            appendTo.appendChild(iframe);
        }

        return iframe;
    };

    const iframe = createIframe({ url: t.href, allow: t.allow, callback: n, appendTo: mediaContainer });
    mediaContainer.parentNode.style.maxWidth = t.width;
    mediaContainer.parentNode.style.height = t.height;
    mediaContainer.appendChild(iframe);
}

// Constructor function to initialize settings with defaults
class U {
    constructor(options = {}) {
        this.defaults = {
            href: "",
            sizes: "",
            srcset: "",
            title: "",
            type: "",
            videoProvider: "",
            description: "",
            alt: "",
            descPosition: "bottom",
            effect: "",
            width: "",
            height: "",
            content: false,
            zoomable: true,
            draggable: true
        };

        // Merge defaults with user-provided options
        if (isObject(options)) {
            this.defaults = { ...this.defaults, ...options };
        }
    }
}

// Helper function to check if a value is an object
function isObject(value) {
    return value && typeof value === 'object' && !Array.isArray(value);
}
const mySlide = document.querySelector('.slide');
const videoOptions = {
    href: 'https://player.vimeo.com/video/123456789',
    width: '640px',
    height: '360px',
    allow: 'autoplay; fullscreen'
};

Z(mySlide, videoOptions, () => {
    console.log('Video iframe loaded');
});

const mySettings = new U({ width: '800px', zoomable: false });
console.log(mySettings.defaults);

class Lightbox {
    // Method to determine the type of source (image or video)
    sourceType(url) {
        // Convert URL to lowercase for case-insensitive matching
        const lowercasedUrl = url.toLowerCase();
        

        // Check if the URL matches an image pattern
      
    
        // Default case if no patterns match
        return "unknown";
    }
}
class Lightbox {
    constructor(settings) {
        this.settings = settings || {};
        this.elements = [];
        this.apiEvents = [];
        this.events = {};
        this.modal = null;
        this.slidesContainer = null;
        this.activeSlide = null;
        this.index = 0;
        this.closing = false;
        this.built = false;
        this.lightboxOpen = false;
        this.bodyHiddenChildElms = [];
        this.fullElementsList = [];
        this.baseEvents = null;
    }

    getElements() {
        const elements = [];
        this.elements = this.elements || [];

        // Retrieve elements from settings
        if (this.settings.elements && Array.isArray(this.settings.elements) && this.settings.elements.length) {
            this.settings.elements.forEach((element, index) => {
                const instance = new ElementWrapper(element, this, index);
                const config = instance.getConfig();
                const configCopy = { ...config, node: false, index, instance, slideConfig: config };
                elements.push(configCopy);
            });
        }

        // Retrieve elements from DOM based on selector
        const selectorElements = document.querySelectorAll(this.getSelector());
        if (selectorElements.length) {
            selectorElements.forEach((element, index) => {
                const instance = new ElementWrapper(element, this, index);
                const config = instance.getConfig();
                const configCopy = {
                    ...config,
                    node: element,
                    index,
                    instance,
                    slideConfig: config,
                    gallery: element.getAttribute("data-gallery"),
                };
                elements.push(configCopy);
            });
        }

        return elements;
    }

    getGalleryElements(elements, gallery) {
        return elements.filter(element => element.gallery === gallery);
    }

    getSelector() {
        if (!this.settings.elements) {
            return this.settings.selector && this.settings.selector.startsWith('data-')
                ? `[${this.settings.selector}]`
                : this.settings.selector;
        }
        return null;
    }

    getActiveSlide() {
        return this.slidesContainer ? this.slidesContainer.querySelectorAll(".gslide")[this.index] : null;
    }

    getActiveSlideIndex() {
        return this.index;
    }

    getAnimationClasses() {
        const animationClasses = [];
        Object.keys(this.settings.cssEffects || {}).forEach(effect => {
            const cssEffect = this.settings.cssEffects[effect];
            animationClasses.push(`g${cssEffect.in}`, `g${cssEffect.out}`);
        });
        return animationClasses.join(" ");
    }

    build() {
        if (this.built) return false;

        const bodyChildren = document.body.childNodes;
        const hiddenElements = [];

        bodyChildren.forEach(child => {
            if (child.parentNode === document.body && !child.nodeName.startsWith('#') && child.hasAttribute && !child.hasAttribute("aria-hidden")) {
                hiddenElements.push(child);
                child.setAttribute("aria-hidden", "true");
            }
        });

        // Create and append modal element
        this.modal = document.createElement('div');
        this.modal.className = 'lightbox-modal';
        document.body.appendChild(this.modal);

        // Create slides container
        this.slidesContainer = document.createElement('div');
        this.slidesContainer.className = 'lightbox-slides-container';
        this.modal.appendChild(this.slidesContainer);

        this.built = true;
    }

    open(index) {
        if (!this.built) this.build();
        this.index = index || 0;
        this.lightboxOpen = true;

        // Display the lightbox modal
        this.modal.style.display = 'block';

        // Update slides
        this.updateSlides();
    }

    close() {
        if (this.lightboxOpen) {
            this.lightboxOpen = false;
            this.modal.style.display = 'none';

            // Restore hidden body elements
            this.bodyHiddenChildElms.forEach(el => el.removeAttribute("aria-hidden"));
            this.bodyHiddenChildElms = [];
        }
    }

    updateSlides() {
        if (!this.slidesContainer) return;

        // Clear existing slides
        this.slidesContainer.innerHTML = '';

        // Add new slides
        const elements = this.getElements();
        const galleryElements = this.getGalleryElements(elements, this.settings.gallery);
        
        galleryElements.forEach((elementConfig) => {
            const slide = document.createElement('div');
            slide.className = 'gslide';
            slide.innerHTML = `<img src="${elementConfig.node.src}" alt="${elementConfig.node.alt}">`; // Example content
            this.slidesContainer.appendChild(slide);
        });

        // Set the active slide
        this.setActiveSlide();
    }

    setActiveSlide() {
        if (!this.slidesContainer) return;

        const slides = this.slidesContainer.querySelectorAll(".gslide");
        slides.forEach((slide, idx) => {
            if (idx === this.index) {
                slide.classList.add('active');
            } else {
                slide.classList.remove('active');
            }
        });
    }
}

  
      const svgNext = this.settings.svg?.next || "";
      const svgPrev = this.settings.svg?.prev || "";
      const svgClose = this.settings.svg?.close || "";
      let lightboxHTML = this.settings.lightboxHTML;
  // Replace SVG placeholders in the lightbox HTML string
lightboxHTML = lightboxHTML
.replace({nextSVG}/g, svgNext)
.replace({prevSVG}/g, svgPrev)
.replace({closeSVG}/g, svgClose);

// Create a new div element
const lightboxElement = document.createElement('div');

// Set the inner HTML of the div to the updated lightbox HTML
lightboxElement.innerHTML = lightboxHTML;

// Append the new element to the body of the document
document.body.appendChild(lightboxElement);

  
      this.modal = document.getElementById("glightbox-body");
      this.prevButton = this.modal.querySelector(".gprev");
      this.nextButton = this.modal.querySelector(".gnext");
      this.overlay = this.modal.querySelector(".goverlay");
      this.loader = this.modal.querySelector(".gloader");
      this.slidesContainer = document.getElementById("glightbox-slider");
      this.bodyHiddenChildElms = hiddenElements;
  
      // Add event listeners
      if (this.settings.closeButton && this.modal.querySelector(".gclose")) {
        this.events.close = this.addEventListener(this.modal.querySelector(".gclose"), 'click', () => this.close());
      }
  
      if (this.nextButton) {
        this.events.next = this.addEventListener(this.nextButton, 'click', () => this.nextSlide());
      }
  
      if (this.prevButton) {
        this.events.prev = this.addEventListener(this.prevButton, 'click', () => this.prevSlide());
      }
  
      if (this.settings.closeOnOutsideClick) {
        this.events.outClose = this.addEventListener(this.modal, 'click', event => {
          if (!this.preventOutsideClick && !event.target.closest('.ginner-container') && !event.target.closest('.gbtn') && !event.target.classList.contains('gnext') && !event.target.classList.contains('gprev')) {
            this.close();
          }
        });
      }
      this.elements.forEach((element, index) => {
        this.slidesContainer.appendChild(element.instance.create());
        element.slideNode = this.slidesContainer.querySelectorAll(".gslide")[index];
      });
  
      if ('ontouchstart' in document.documentElement) {
        document.body.classList.add("glightbox-touch");
      }
  
      this.events.resize = this.addEventListener(window, 'resize', () => this.resize());
  
      this.built = true;
  
      class Lightbox {
        constructor(settings) {
            this.settings = settings || {};
            this.elements = [];
            this.apiEvents = [];
            this.events = {};
            this.modal = null;
            this.slidesContainer = null;
            this.activeSlide = null;
            this.index = 0;
            this.closing = false;
            this.built = false;
            this.lightboxOpen = false;
            this.bodyHiddenChildElms = [];
            this.fullElementsList = [];
            this.baseEvents = null;
            this.prevActiveSlideIndex = null;
            this.prevActiveSlide = null;
            this.nextButton = null; // Assuming these are initialized elsewhere
            this.prevButton = null;
            this.overlay = null; // Assuming this is initialized elsewhere
        }
    
        reload() {
            this.init(); // Assuming `init` initializes or reinitializes the lightbox
        }
    
        updateNavigationClasses() {
            const loop = this.loop();
            this.nextButton.classList.remove('disabled');
            this.prevButton.classList.remove('disabled');
    
            if (this.index === 0 && this.elements.length === 1) {
                this.prevButton.classList.add('disabled');
                this.nextButton.classList.add('disabled');
            } else if (this.index === 0) {
                this.prevButton.classList.add('disabled');
            } else if (this.index === this.elements.length - 1 && !loop) {
                this.nextButton.classList.add('disabled');
            } else if (this.index === this.elements.length - 1 && loop) {
                this.nextButton.classList.remove('disabled');
            } else if (loop) {
                this.prevButton.classList.remove('disabled');
                this.nextButton.classList.remove('disabled');
            }
        }
    
        loop() {
            return this.settings.loopAtEnd ?? this.settings.loop;
        }
    
        close() {
            if (!this.lightboxOpen || this.closing) return false;
    
            this.closing = true;
            this.pauseSlidePlayer(this.activeSlide); // Assuming this method pauses any slide player
    
            if (this.fullElementsList.length) {
                this.elements = this.fullElementsList;
            }
    
            this.bodyHiddenChildElms.forEach(elm => elm.removeAttribute("aria-hidden"));
    
            this.modal.classList.add("glightbox-closing");
            this.overlay.style.display = this.settings.openEffect === "none" ? "none" : this.settings.cssEffects.fade.out;
            this.activeSlide.classList.add(this.settings.cssEffects[this.settings.closeEffect]?.out || '');
    
            setTimeout(() => {
                this.activeSlide = null;
                this.prevActiveSlideIndex = null;
                this.prevActiveSlide = null;
                this.built = false;
    
                if (this.events) {
                    Object.values(this.events).forEach(event => event.destroy());
                    this.events = null;
                }
    
                document.body.classList.remove("glightbox-open", "touching", "gdesc-open", "glightbox-touch", "glightbox-mobile", "gscrollbar-fixer");
                if (this.modal && this.modal.parentNode) {
                    this.modal.parentNode.removeChild(this.modal);
                }
    
                this.trigger("close"); // Assuming this method triggers a custom event
                if (typeof this.settings.onClose === "function") {
                    this.settings.onClose();
                }
    
                const cssStyles = document.querySelector(".gcss-styles");
                if (cssStyles) {
                    cssStyles.parentNode.removeChild(cssStyles);
                }
    
                this.lightboxOpen = false;
                this.closing = false; // Changed from `null` to `false` for consistency
            }, 300); // Duration of the closing animation
        }
    
        // Dummy implementations for missing methods
        init() {
            // Initialize or reinitialize the lightbox
        }
    
        pauseSlidePlayer(slide) {
            // Pause any slide player if present
        }
    
        trigger(event) {
            // Trigger a custom event
        }
    }
    
  
  
   